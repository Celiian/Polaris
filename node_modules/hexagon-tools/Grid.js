var HT_HEXAGON_ORIENTATION = {
	Normal: 0,
	Rotated: 1
};

/**
 * A Grid is the model of the playfield containing hexes
 * @constructor
 */
var HT_GRID = function(width, height, gap, hexagonSize, hexagonSide) {
	var HT_HEXAGON_STATIC = HT_HEXAGON_STATIC || {
		ORIENTATION: HT_HEXAGON_ORIENTATION.Normal,
		WIDTH: hexagonSize,
		HEIGHT: hexagonSize,
		SIDE: hexagonSide,
		GAP: gap
	};

	this.hexagons = [];
	//setup a dictionary for use later for assigning the X or Y CoOrd (depending on Orientation)
	var HexagonsByXOrYCoOrd = {}; //Dictionary<int, List<Hexagon>>

	var row = 0;
	var y = 0.0;
	while (y + HT_HEXAGON_STATIC.HEIGHT + (HT_HEXAGON_STATIC.GAP * row) <= height)
	{
		var col = 0;

		var offset = 0.0;
		if (row % 2 == 1)
		{
			if(HT_HEXAGON_STATIC.ORIENTATION == HT_HEXAGON_ORIENTATION.Normal)
				offset = (HT_HEXAGON_STATIC.WIDTH - HT_HEXAGON_STATIC.SIDE)/2 + HT_HEXAGON_STATIC.SIDE;
			else
				offset = HT_HEXAGON_STATIC.WIDTH / 2;
			col = 1;
		}

		var x = offset;
		while (x + HT_HEXAGON_STATIC.WIDTH  + (HT_HEXAGON_STATIC.GAP * col * 2) + (HT_HEXAGON_STATIC.GAP * 2) <= width)
		{
		    var hexId = this.GetHexId(row, col);
			var h = {
				id: hexId,
				x: x  + (HT_HEXAGON_STATIC.GAP * col * 2),
				y: y + (HT_HEXAGON_STATIC.GAP * row)
			};

			var pathCoOrd = col;
			if(HT_HEXAGON_STATIC.ORIENTATION == HT_HEXAGON_ORIENTATION.Normal)
				h.PathCoOrdX = col;//the column is the x coordinate of the hex, for the y coordinate we need to get more fancy
			else {
				h.PathCoOrdY = row;
				pathCoOrd = row;
			}

			this.hexagons.push(h);

			if (!HexagonsByXOrYCoOrd[pathCoOrd])
				HexagonsByXOrYCoOrd[pathCoOrd] = [];
			HexagonsByXOrYCoOrd[pathCoOrd].push(h);

			col+=2;
			if(HT_HEXAGON_STATIC.ORIENTATION == HT_HEXAGON_ORIENTATION.Normal)
				x += HT_HEXAGON_STATIC.WIDTH + HT_HEXAGON_STATIC.SIDE;
			else
				x += HT_HEXAGON_STATIC.WIDTH;
		}
		row++;
		if(HT_HEXAGON_STATIC.ORIENTATION == HT_HEXAGON_ORIENTATION.Normal)
			y += HT_HEXAGON_STATIC.HEIGHT / 2;
		else
			y += (HT_HEXAGON_STATIC.HEIGHT - HT_HEXAGON_STATIC.SIDE)/2 + HT_HEXAGON_STATIC.SIDE;
	}

	//finally go through our list of hexagons by their x co-ordinate to assign the y co-ordinate
	for (var coOrd1 in HexagonsByXOrYCoOrd)
	{
		var hexagonsByXOrY = HexagonsByXOrYCoOrd[coOrd1];
		var coOrd2 = Math.floor(coOrd1 / 2) + (coOrd1 % 2);
		for (var i in hexagonsByXOrY)
		{
			var h = hexagonsByXOrY[i];//Hexagon
			if(HT_HEXAGON_STATIC.ORIENTATION == HT_HEXAGON_ORIENTATION.Normal)
				h.PathCoOrdY = coOrd2++;
			else
				h.PathCoOrdX = coOrd2++;
		}
	}
};

HT_GRID.Static = {Letters:'ABCDEFGHIJKLMNOPQRSTUVWXYZ'};

HT_GRID.prototype.GetHexId = function(row, col) {
	var letterIndex = row;
	var letters = "";
	while(letterIndex > 25)
	{
		letters = HT_GRID.Static.Letters[letterIndex%26] + letters;
		letterIndex -= 26;
	}

	return HT_GRID.Static.Letters[letterIndex] + letters + (col + 1);
};

/**
 * Returns a hex at a given point
 * @this {HT_GRID}
 * @return {HT.Hexagon}
 */
HT_GRID.prototype.GetHexAt = function(/*Point*/ p) {
	//find the hex that contains this point
	for (var h in this.hexagons)
	{
		if (this.hexagons[h].Contains(p))
		{
			return this.hexagons[h];
		}
	}

	return null;
};

/**
 * Returns a distance between two hexes
 * @this {HT_GRID}
 * @return {number}
 */
HT_GRID.prototype.GetHexDistance = function(/*Hexagon*/ h1, /*Hexagon*/ h2) {
	//a good explanation of this calc can be found here:
	//http://playtechs.blogspot.com/2007/04/hex-grids.html
	var deltaX = h1.PathCoOrdX - h2.PathCoOrdX;
	var deltaY = h1.PathCoOrdY - h2.PathCoOrdY;
	return ((Math.abs(deltaX) + Math.abs(deltaY) + Math.abs(deltaX - deltaY)) / 2);
};

/**
 * Returns a distance between two hexes
 * @this {HT_GRID}
 * @return {HT.Hexagon}
 */
HT_GRID.prototype.GetHexById = function(id) {
	for(var i in this.hexagons)
	{
		if(this.hexagons[i].Id == id)
		{
			return this.hexagons[i];
		}
	}
	return null;
};

/**
* Returns the nearest hex to a given point
* Provided by: Ian (Disqus user: boingy)
* @this {HT_GRID}
* @param {HT.Point} p the test point
* @return {HT.Hexagon}
*/
HT_GRID.prototype.GetNearestHex = function(/*Point*/ p) {

	var distance;
	var minDistance = Number.MAX_VALUE;
	var hx = null;

	// iterate through each hex in the grid
	for (var h in this.hexagons) {
		distance = this.hexagons[h].distanceFromMidPoint(p);

		if (distance < minDistance) // if this is the nearest thus far
		{
			minDistance = distance;
			hx = this.hexagons[h];
		}
	}

	return hx;
};

module.exports = HT_GRID;
