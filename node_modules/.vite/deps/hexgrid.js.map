{
  "version": 3,
  "sources": ["../../point2d/index.js", "../../hexgrid/index.js"],
  "sourcesContent": ["\n/**\n * An immutable point in 2d space\n * @param {Number} x The x coordinate\n * @param {Number} y The y coordinate\n */\nfunction Point (x, y) {\n  this.x = x || 0;\n  this.y = y || 0;\n  Object.freeze(this);\n}\n\n/**\n * Returns the Euclidean distance between this point and another point\n * @param {Point} point The other point\n * @returns {Number} The Euclidean distance\n */\nPoint.prototype.distance = function (point) {\n  return Math.sqrt(Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2));\n};\n\n/**\n * Returns the Manhattan distance between this point and another point\n * @param {Point} point The other point\n * @returns {Number} The Manhattan distance\n */\nPoint.prototype.manhattanDistance = function (point) {\n  var scalePoint = this.sub(point).abs();\n  return scalePoint.x + scalePoint.y;\n};\n\n/**\n * Returns a new point with coordinates in absolute value\n * @returns {Point} The new point\n */\nPoint.prototype.abs = function () {\n  return new Point(Math.abs(this.x), Math.abs(this.y));\n};\n\n/**\n * Returns true if the x and y coordinate of this point equals the x and y coordinate of the other point\n * @param {Point} point The other point\n * @returns {Boolean} If the points equal\n */\nPoint.prototype.equals = function (point) {\n  return this.x === point.x && this.y === point.y;\n};\n\n/**\n * Returns a new point with the coordinates added together\n * @param {Point} point The other point\n * @returns {Point} A new point\n */\nPoint.prototype.add = function (point) {\n  return new Point(this.x + point.x, this.y + point.y);\n};\n\n/**\n * Returns a new point with the coordinates of this point subtracted by the other point\n * @param {Point} point The other point\n * @returns {Point} The new point\n */\nPoint.prototype.sub = function (point) {\n  return new Point(this.x - point.x, this.y - point.y);\n};\n\nmodule.exports = Point;", "\nvar Point = require('point2d');\n\n/**\n * A hexagonal grid layout\n * Uses axial/trapezoidal coordinate space with pointy-top hexagons\n * - Increasing x goes right\n * - Increasing y goes bottom right\n * @param {Object} options Extra options\n */\nfunction Hexgrid (options) {\n  options = options || {};\n  // The distance between the center of a hexagon and a corner in pixels\n  this.size = options.size || 100;\n  // The displacement of the Hexgrid. By default this is (0,0) and represents the center of the hexcell at (0,0)\n  this.origin = options.origin || new Point();\n\n  // Derived properties\n  //\n  // height: The height of a hexagon\n  // width: The width of a hexagon\n  // vertSpacing: The vertical spacing between hexagons\n  // horiSpacing: The horizontal spacing between hexagons\n  this._height = this.size * 2;\n  this._width = (Math.sqrt(3) / 2) * this._height;\n  this._vertSpacing = (3/4) * this._height;\n  this._horiSpacing = this._width;\n\n  // Where all the hexagons are stored\n  this._grid = {};\n}\n\nHexgrid.prototype = {\n  /**\n   * Adds a hexagon to the grid. If the grid already has a hexagon there, it replaces the hexagon\n   * @param {Hexcell} hexcell The new hexagon cell\n   */\n  add: function (hexcell) {\n    // add row if doesn't exist\n    var row = this._grid[hexcell.point.y];\n    if (!row) {\n      this._grid[hexcell.point.y] = {};\n    }\n\n    // add hexagon to row\n    this._grid[hexcell.point.y][hexcell.point.x] = hexcell;\n  },\n\n  /**\n   * Removes a hexcell at a point\n   * @param {Point} point The point to remove the cell from\n   */\n  remove: function (point) {\n    if (this._grid[point.y]) {\n      delete this._grid[point.y][point.x];\n    }\n  },\n\n  /**\n   * Gets the hexcell at a point\n   * @param {Point} point The point to get the cell at\n   * @returns {Hexcell} The cell at this point\n   */\n  get: function (point) {\n    if (!this.isEmpty(point)) {\n      return this._grid[point.y][point.x];\n    }\n  },\n\n  /**\n   * Gets the center of the hexcell as a Cartesian point.\n   * Translates the hexcell's axial coordinate system point to Cartesian.\n   * @param {Point} hexcell The point of the hexcell\n   * @returns {Point} The center of the hexcell\n   */\n  getXY: function (point) {\n    var x = (point.x * this._horiSpacing) + (point.y * this._horiSpacing * 0.5);\n    x += this.origin.x - (this._width * 0.5);\n    var y = (point.y * this._vertSpacing);\n    y += this.origin.y - (this._height * 0.5);\n    var xy = new Point(x, y);\n    return xy;\n  },\n\n  /**\n   * Returns true if the grid is empty at the given point\n   * @param {Point} point The point to check\n   * @returns {Boolean} True if the cell is empty\n   */\n  isEmpty: function (point) {\n    var row = this._grid[point.y];\n    return !row || !row[point.x];\n  },\n\n  /**\n   * Gets all the hexcells in an array\n   * @returns {Hexcell[]} An array of hexcells\n   */\n  getHexcells: function () {\n    var cells = [];\n    for (var rowIndex in this._grid) {\n      var row = this._grid[rowIndex];\n      for (var columnIndex in row) {\n        var column = this._grid[rowIndex][columnIndex];\n        cells.push(column);\n      }\n    }\n    return cells;\n  }\n};\n\nmodule.exports = Hexgrid;"],
  "mappings": "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",
  "names": []
}
